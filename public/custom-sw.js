// This is a custom service worker that will be used in addition to the one generated by next-pwa

// Set up global error handling
self.__WB_DISABLE_DEV_LOGS = true; // Disable verbose workbox logs

// List of critical pages to cache for offline use
const CRITICAL_PAGES = [
  '/',
  '/offline',
  '/dashboard',
  '/dashboard/clients',
  '/dashboard/schedule',
  '/dashboard/exercises',
  '/dashboard/workouts',
  '/dashboard/clients/new',
  '/dashboard/schedule/new',
  '/dashboard/exercises/new',
  '/dashboard/workouts/new',
  '/dashboard/progress',
  '/dashboard/invoices',
  '/dashboard/invoices/new',
  '/dashboard/pricing-packages',
  '/settings'
];

// List of API routes to cache for offline use
const API_ROUTES_TO_CACHE = [
  '/api/clients',
  '/api/schedules',
  '/api/exercises',
  '/api/workouts',
  '/api/progress',
  '/api/invoices',
  '/api/pricing-packages'
];

// Wrap all code in try-catch to prevent service worker crashes
try {
  // Handle precaching errors gracefully
  self.addEventListener('error', (event) => {
    console.error('Service Worker error:', event.error);
    // Prevent the error from crashing the service worker
    event.preventDefault();
  });

  self.addEventListener('unhandledrejection', (event) => {
    // Check if this is a precaching error or any other error
    if (event.reason) {
      console.warn('Promise rejection in Service Worker handled:', event.reason);

      // Prevent the error from crashing the service worker
      event.preventDefault();
    }
  });

  // Add global error handler
  self.onerror = function(message, source, lineno, colno, error) {
    console.warn('Global error in Service Worker:', { message, source, lineno, colno });
    // Return true to prevent the error from being reported to the console
    return true;
  };

  // Cache critical pages on install
  self.addEventListener('install', (event) => {
    console.log('[Service Worker] Installing...');

    event.waitUntil(
      Promise.all([
        // Cache pages
        caches.open(CACHE_NAMES.pages)
          .then(cache => {
            console.log('[Service Worker] Caching critical pages');
            // Add offline page first to ensure it's available
            return cache.add('/offline')
              .then(() => {
                // Then try to cache other critical pages
                return Promise.allSettled(
                  CRITICAL_PAGES.map(url =>
                    cache.add(url).catch(err =>
                      console.warn(`[Service Worker] Failed to cache ${url}:`, err)
                    )
                  )
                );
              })
              .catch(err => {
                console.error('[Service Worker] Failed to cache offline page:', err);
                // Continue installation even if caching fails
              });
          }),

        // Cache API routes
        caches.open(CACHE_NAMES.api)
          .then(cache => {
            console.log('[Service Worker] Caching API routes');
            return Promise.allSettled(
              API_ROUTES_TO_CACHE.map(url =>
                fetch(url)
                  .then(response => {
                    if (response.ok) {
                      return cache.put(url, response);
                    }
                    throw new Error(`Failed to fetch ${url}`);
                  })
                  .catch(err => {
                    console.warn(`[Service Worker] Failed to cache API route ${url}:`, err);
                  })
              )
            );
          })
          .catch(err => {
            console.error('[Service Worker] Failed to cache API routes:', err);
            // Continue installation even if API caching fails
          })
      ])
    );
  });
} catch (setupError) {
  console.error('Error setting up service worker error handlers:', setupError);
}

// Cache names
const CACHE_NAMES = {
  static: 'fitcoachpro-static-v3', // Increment version to clear old caches
  dynamic: 'fitcoachpro-dynamic-v3',
  pages: 'fitcoachpro-pages-v3',
  api: 'fitcoachpro-api-v3'
};

// Check if we're online
const checkOnlineStatus = () => {
  return new Promise(resolve => {
    const timeout = setTimeout(() => {
      // If we timeout, assume we're offline
      resolve(false);
    }, 2000);

    fetch('/manifest.json', { method: 'HEAD' })
      .then(() => {
        clearTimeout(timeout);
        resolve(true);
      })
      .catch(() => {
        clearTimeout(timeout);
        resolve(false);
      });
  });
};

// Track last sync time to prevent infinite loops
let lastSyncTime = 0;

// Add an activate event to clean up old caches
self.addEventListener('activate', (event) => {
  console.log('[Service Worker] Activating...');

  // Get all cache keys
  event.waitUntil(
    caches.keys().then(cacheNames => {
      return Promise.all(
        cacheNames.map(cacheName => {
          // Check if this cache doesn't match any of our current cache names
          if (
            !Object.values(CACHE_NAMES).includes(cacheName) &&
            cacheName.startsWith('fitcoachpro-')
          ) {
            console.log('[Service Worker] Deleting old cache:', cacheName);
            return caches.delete(cacheName);
          }
        })
      );
    }).then(() => {
      console.log('[Service Worker] Claiming clients...');
      return self.clients.claim();
    })
  );
});

// Listen for the 'sync' event to handle background syncing
self.addEventListener('sync', (event) => {
  console.log('[Service Worker] Background sync event:', event.tag);

  if (event.tag === 'sync-data') {
    const now = Date.now();

    // Only process sync events if it's been more than 30 seconds since the last one
    if (now - lastSyncTime > 30000) {
      lastSyncTime = now;

      // Notify all clients that they should sync data
      self.clients.matchAll().then((clients) => {
        if (clients.length > 0) {
          console.log(`[Service Worker] Notifying ${clients.length} clients to sync data`);

          // Only notify one client to prevent multiple syncs
          const mainClient = clients[0];
          mainClient.postMessage({
            type: 'SYNC_DATA',
            timestamp: now
          });
        } else {
          console.log('[Service Worker] No clients to notify');
        }
      });
    } else {
      console.log('[Service Worker] Ignoring sync event (too frequent)');
    }
  }
});

// Listen for messages from clients
self.addEventListener('message', (event) => {
  // Handle data change notifications
  if (event.data && event.data.type === 'DATA_CHANGED') {
    const { table, operation, id } = event.data;
    console.log(`[Service Worker] Data changed: ${operation} in ${table}`);

    // Notify all other clients about the data change
    self.clients.matchAll().then((clients) => {
      clients.forEach((client) => {
        // Don't send back to the originating client
        if (client.id !== event.source.id) {
          client.postMessage({
            type: 'DATA_CHANGED',
            table,
            operation,
            id
          });
        }
      });
    });
  }

  // Handle skip waiting message
  if (event.data && event.data.type === 'SKIP_WAITING') {
    self.skipWaiting();
  }
});

// Add a custom fetch handler for the offline page
self.addEventListener('fetch', (event) => {
  try {
    // Skip non-GET requests
    if (event.request.method !== 'GET') {
      return;
    }

    // Skip non-HTTP/HTTPS requests
    const url = event.request.url;
    if (!url.startsWith('http://') && !url.startsWith('https://')) {
      return;
    }

    // Skip browser extensions, analytics, and Vercel scripts
    if (url.includes('chrome-extension') ||
        url.includes('firefox-extension') ||
        url.includes('analytics') ||
        url.includes('sentry') ||
        url.includes('vercel/insights') ||
        url.includes('_vercel/')) {
      // For Vercel scripts, return an empty response to prevent errors
      if (url.includes('vercel/insights') || url.includes('_vercel/')) {
        event.respondWith(
          new Response('', {
            status: 200,
            headers: { 'Content-Type': 'application/javascript' }
          })
        );
      }
      return;
    }

    // Handle problematic files specially to prevent precaching errors
    if (url.includes('app-build-manifest.json') ||
        url.includes('middleware-manifest.json') ||
        url.includes('_error.js') ||
        url.includes('workbox-error-handler.js')) {
      event.respondWith(
        fetch(event.request)
          .catch(() => {
            // Return an empty JSON object if the file can't be fetched
            return new Response(JSON.stringify({}), {
              status: 200,
              headers: { 'Content-Type': 'application/json' }
            });
          })
      );
      return;
    }
  } catch (error) {
    console.warn('Error in fetch event handler initial checks:', error);
    return; // Continue with default browser fetch behavior
  }

  try {
    // Get the URL from the request
    const url = event.request.url;

    // Check online status
    const isOnline = self.navigator ? self.navigator.onLine : true;

    // Check if this is an API request
    const isApiRequest = url.includes('/api/') || url.includes('supabase');

    // For API requests, use network first strategy
    if (isApiRequest) {
      event.respondWith(
        (async () => {
          try {
            // Try network first
            const response = await fetch(event.request);

            // Cache successful API responses for offline use
            if (response.ok) {
              try {
                const responseToCache = response.clone();
                const cache = await caches.open(CACHE_NAMES.api);
                await cache.put(event.request, responseToCache);
                console.log(`[Service Worker] Cached API response for: ${event.request.url}`);
              } catch (cacheError) {
                console.warn('Error caching API response:', cacheError);
              }
            }

            return response;
          } catch (networkError) {
            console.log(`[Service Worker] Network request failed for API: ${event.request.url}, falling back to cache`);

            try {
              // If network fails, try to get from cache
              const cachedResponse = await caches.match(event.request);
              if (cachedResponse) {
                console.log(`[Service Worker] Serving API request from cache: ${event.request.url}`);
                return cachedResponse;
              }

              // Check if this is one of our predefined API routes
              const url = new URL(event.request.url);
              const pathname = url.pathname;

              // Try to find a matching API route in our predefined list
              const matchingApiRoute = API_ROUTES_TO_CACHE.find(route => pathname.startsWith(route));
              if (matchingApiRoute) {
                const fallbackResponse = await caches.match(matchingApiRoute);
                if (fallbackResponse) {
                  console.log(`[Service Worker] Serving API request from fallback cache: ${matchingApiRoute}`);
                  return fallbackResponse;
                }
              }

              // If no cache match, return an empty but valid JSON response
              return new Response('{"data":[],"error":null}', {
                status: 200,
                headers: { 'Content-Type': 'application/json' }
              });
            } catch (cacheError) {
              console.warn('Error getting API request from cache:', cacheError);
              return new Response('{"error":"Network error"}', {
                status: 503,
                headers: { 'Content-Type': 'application/json' }
              });
            }
          }
        })()
      );
      return;
    }

    // For navigation requests (HTML pages)
    if (event.request.mode === 'navigate') {
      event.respondWith(
        (async () => {
          try {
            // Try network first
            const networkResponse = await fetch(event.request);

            // If successful, cache the response
            if (networkResponse.ok) {
              try {
                const responseToCache = networkResponse.clone();
                const cache = await caches.open(CACHE_NAMES.pages);
                await cache.put(event.request, responseToCache);

                // Also cache critical pages when user navigates to them
                if (CRITICAL_PAGES.includes(new URL(event.request.url).pathname)) {
                  console.log(`[Service Worker] User visited critical page: ${event.request.url}`);
                }
              } catch (cacheError) {
                console.warn('[Service Worker] Error caching navigation response:', cacheError);
              }
            }

            return networkResponse;
          } catch (networkError) {
            console.log('[Service Worker] Network request failed, falling back to cache');

            try {
              // Try to get the page from cache
              const cachedResponse = await caches.match(event.request);
              if (cachedResponse) {
                console.log('[Service Worker] Serving from cache:', event.request.url);
                return cachedResponse;
              }

              // If page not in cache, return the offline page
              console.log('[Service Worker] Page not in cache, serving offline page');
              const offlineResponse = await caches.match('/offline');
              if (offlineResponse) {
                return offlineResponse;
              }

              // If offline page is not in cache, return a simple offline message
              return new Response(
                `<!DOCTYPE html>
                <html lang="en">
                <head>
                  <meta charset="UTF-8">
                  <meta name="viewport" content="width=device-width, initial-scale=1.0">
                  <title>Offline - FitCoachPro</title>
                  <style>
                    body { font-family: system-ui, -apple-system, sans-serif; padding: 2rem; text-align: center; }
                    h1 { margin-bottom: 1rem; }
                    p { margin-bottom: 2rem; color: #666; }
                    button { background: #2563EB; color: white; border: none; padding: 0.75rem 1.5rem;
                            border-radius: 0.375rem; cursor: pointer; }
                  </style>
                </head>
                <body>
                  <h1>You're offline</h1>
                  <p>Please check your internet connection and try again.</p>
                  <button onclick="window.location.reload()">Try Again</button>
                </body>
                </html>`,
                {
                  status: 200,
                  headers: { 'Content-Type': 'text/html' }
                }
              );
            } catch (cacheError) {
              console.error('[Service Worker] Error serving from cache:', cacheError);
              return new Response('Service unavailable. Please try again later.', {
                status: 503,
                headers: { 'Content-Type': 'text/html' }
              });
            }
          }
        })()
      );
      return;
    }

    // For all other requests, use cache first, falling back to network
    event.respondWith(
      caches.match(event.request)
        .then(cachedResponse => {
          if (cachedResponse) {
            // Return cached response and update cache in background
            if (isOnline) {
              try {
                fetch(event.request)
                  .then(response => {
                    if (response.ok) {
                      caches.open(CACHE_NAMES.dynamic)
                        .then(cache => {
                          cache.put(event.request, response);
                        })
                        .catch(err => console.warn('Error updating cache in background:', err));
                    }
                  })
                  .catch(() => {
                    // Ignore network errors for background updates
                  });
              } catch (backgroundUpdateError) {
                console.warn('Error in background cache update:', backgroundUpdateError);
              }
            }
            return cachedResponse;
          }

          // If not in cache, fetch from network
          return fetch(event.request)
            .then(response => {
              if (!response || !response.ok) {
                return response;
              }

              try {
                // Cache the response
                const responseToCache = response.clone();
                caches.open(CACHE_NAMES.dynamic)
                  .then(cache => {
                    cache.put(event.request, responseToCache);
                  })
                  .catch(err => console.warn('Error caching response:', err));
              } catch (cacheError) {
                console.warn('Error handling response caching:', cacheError);
              }

              return response;
            })
            .catch(() => {
              // For image requests, return an empty response
              if (event.request.destination === 'image') {
                return new Response('', { status: 404 });
              }

              // For other requests, return a generic error
              return new Response('Network error', { status: 503 });
            });
        })
        .catch(err => {
          console.warn('Error in cache match:', err);
          // Fall back to network if cache matching fails
          return fetch(event.request)
            .catch(() => new Response('Service unavailable', { status: 503 }));
        })
    );
  } catch (fetchHandlerError) {
    console.error('Critical error in fetch handler:', fetchHandlerError);
    // Let the browser handle the request normally
    return;
  }
});
